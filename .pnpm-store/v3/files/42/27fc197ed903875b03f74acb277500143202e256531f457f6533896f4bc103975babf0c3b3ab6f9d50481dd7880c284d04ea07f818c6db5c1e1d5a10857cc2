import { Theme } from "../theme";
import { Renderer } from "../renderer";
import { Reflection, ReflectionKind, ProjectReflection, ContainerReflection, DeclarationReflection } from "../../models/reflections/index";
import { ReflectionGroup } from "../../models/ReflectionGroup";
import { UrlMapping } from "../models/UrlMapping";
import { NavigationItem } from "../models/NavigationItem";
/**
 * Defines a mapping of a [[Models.Kind]] to a template file.
 *
 * Used by [[DefaultTheme]] to map reflections to output files.
 */
export interface TemplateMapping {
    /**
     * [[DeclarationReflection.kind]] this rule applies to.
     */
    kind: ReflectionKind[];
    /**
     * Can this mapping have children or should all further reflections be rendered
     * to the defined output page?
     */
    isLeaf: boolean;
    /**
     * The name of the directory the output files should be written to.
     */
    directory: string;
    /**
     * The name of the template that should be used to render the reflection.
     */
    template: string;
}
/**
 * Default theme implementation of TypeDoc. If a theme does not provide a custom
 * [[BaseTheme]] implementation, this theme class will be used.
 */
export declare class DefaultTheme extends Theme {
    /**
     * Mappings of reflections kinds to templates used by this theme.
     */
    static MAPPINGS: TemplateMapping[];
    static URL_PREFIX: RegExp;
    /**
     * Create a new DefaultTheme instance.
     *
     * @param renderer  The renderer this theme is attached to.
     * @param basePath  The base path of this theme.
     */
    constructor(renderer: Renderer, basePath: string);
    /**
     * Test whether the given path contains a documentation generated by this theme.
     *
     * @param path  The path of the directory that should be tested.
     * @returns     TRUE if the given path seems to be a previous output directory,
     *              otherwise FALSE.
     */
    isOutputDirectory(path: string): boolean;
    /**
     * Map the models of the given project to the desired output files.
     *
     * @param project  The project whose urls should be generated.
     * @returns        A list of [[UrlMapping]] instances defining which models
     *                 should be rendered to which files.
     */
    getUrls(project: ProjectReflection): UrlMapping[];
    /**
     * Create a navigation structure for the given project.
     *
     * @param project  The project whose navigation should be generated.
     * @returns        The root navigation item.
     */
    getNavigation(project: ProjectReflection): NavigationItem;
    /**
     * Triggered before the renderer starts rendering a project.
     *
     * @param event  An event object describing the current render operation.
     */
    private onRendererBegin;
    /**
     * Return a url for the given reflection.
     *
     * @param reflection  The reflection the url should be generated for.
     * @param relative    The parent reflection the url generation should stop on.
     * @param separator   The separator used to generate the url.
     * @returns           The generated url.
     */
    static getUrl(reflection: Reflection, relative?: Reflection, separator?: string): string;
    /**
     * Return the template mapping for the given reflection.
     *
     * @param reflection  The reflection whose mapping should be resolved.
     * @returns           The found mapping or undefined if no mapping could be found.
     */
    static getMapping(reflection: DeclarationReflection): TemplateMapping | undefined;
    /**
     * Build the url for the the given reflection and all of its children.
     *
     * @param reflection  The reflection the url should be created for.
     * @param urls        The array the url should be appended to.
     * @returns           The altered urls array.
     */
    static buildUrls(reflection: DeclarationReflection, urls: UrlMapping[]): UrlMapping[];
    /**
     * Generate an anchor url for the given reflection and all of its children.
     *
     * @param reflection  The reflection an anchor url should be created for.
     * @param container   The nearest reflection having an own document.
     */
    static applyAnchorUrl(reflection: Reflection, container: Reflection): void;
    /**
     * Generate the css classes for the given reflection and apply them to the
     * [[DeclarationReflection.cssClasses]] property.
     *
     * @param reflection  The reflection whose cssClasses property should be generated.
     */
    static applyReflectionClasses(reflection: DeclarationReflection): void;
    /**
     * Generate the css classes for the given reflection group and apply them to the
     * [[ReflectionGroup.cssClasses]] property.
     *
     * @param group  The reflection group whose cssClasses property should be generated.
     */
    static applyGroupClasses(group: ReflectionGroup): void;
    /**
     * Transform a space separated string into a string suitable to be used as a
     * css class, e.g. "constructor method" > "Constructor-method".
     */
    static toStyleClass(str: string): string;
}
export declare class NavigationBuilder {
    private project;
    private entryPoint;
    private multipleEntryPoints;
    constructor(project: ProjectReflection, entryPoint: ContainerReflection, multipleEntryPoints: boolean);
    /**
     * Build the navigation structure.
     *
     * @param hasReadmeFile True if the project has a readme
     * @returns The root node of the generated navigation structure.
     */
    build(hasReadmeFile: boolean): NavigationItem;
    /**
     * Create navigation nodes for the given list of reflections. The resulting nodes will be grouped into
     * an "internal" and an "external" section when applicable.
     *
     * @param reflections  The list of reflections which should be transformed into navigation nodes.
     * @param parent       The parent NavigationItem of the newly created nodes.
     * @param buildChildren Whether navigation nodes should also be built for the children of each reflection.
     */
    protected buildGroups(reflections: DeclarationReflection[], parent: NavigationItem, buildChildren?: boolean): void;
    /**
     * Create navigation nodes for all container children of the given reflection.
     *
     * @param reflection  The reflection whose children modules should be transformed into navigation nodes.
     * @param parent      The parent NavigationItem of the newly created nodes.
     */
    protected buildChildren(reflection: DeclarationReflection, parent: NavigationItem): void;
    /**
     * Test whether the given list of modules contains an external module.
     *
     * @param modules  The list of modules to test.
     * @returns        TRUE if any of the modules is marked as being external.
     */
    protected containsExternals(modules: DeclarationReflection[]): boolean;
    /**
     * Sort the given list of modules by name, groups external modules at the bottom.
     *
     * @param modules  The list of modules that should be sorted.
     */
    protected sortReflections(modules: DeclarationReflection[]): void;
    /**
     * Find the urls of all children of the given reflection and store them as dedicated urls
     * of the given NavigationItem.
     *
     * @param reflection  The reflection whose children urls should be included.
     * @param item        The navigation node whose dedicated urls should be set.
     */
    protected includeDedicatedUrls(reflection: DeclarationReflection, item: NavigationItem): void;
}
