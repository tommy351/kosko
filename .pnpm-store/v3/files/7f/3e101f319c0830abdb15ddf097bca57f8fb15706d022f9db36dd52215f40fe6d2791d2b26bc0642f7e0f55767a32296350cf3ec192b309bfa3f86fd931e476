{"version":3,"file":"index.js","sources":["../src/util.js","../src/index.js"],"sourcesContent":["import { isTransparentExprWrapper } from \"@babel/helper-skip-transparent-expression-wrappers\";\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n * It respects transparent expression wrappers defined in\n * \"@babel/helper-skip-transparent-expression-wrappers\"\n *\n * @example\n * // returns true\n * const nodePathADotB = NodePath(\"if (a.b) {}\").get(\"test\"); // a.b\n * willPathCastToBoolean(nodePathADotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a.b\"))\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n\n/**\n * Return the outermost transparent expression wrapper of a given path,\n * otherwise returns path itself.\n * @example\n * const nodePathADotB = NodePath(\"(a.b as any)\").get(\"expression\"); // a.b\n * // returns NodePath(\"(a.b as any)\")\n * findOutermostTransparentParent(nodePathADotB);\n * @param {NodePath} path\n * @returns {NodePath}\n */\nexport function findOutermostTransparentParent(path: NodePath): NodePath {\n  let maybeWrapped = path;\n  path.findParent(p => {\n    if (!isTransparentExprWrapper(p)) return true;\n    maybeWrapped = p;\n  });\n  return maybeWrapped;\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport {\n  isTransparentExprWrapper,\n  skipTransparentExprWrappers,\n} from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport syntaxOptionalChaining from \"@babel/plugin-syntax-optional-chaining\";\nimport { types as t, template } from \"@babel/core\";\nimport { willPathCastToBoolean, findOutermostTransparentParent } from \"./util\";\n\nconst { ast } = template.expression;\n\nexport default declare((api, options) => {\n  api.assertVersion(7);\n\n  const { loose = false } = options;\n  const noDocumentAll = api.assumption(\"noDocumentAll\") ?? loose;\n  const pureGetters = api.assumption(\"pureGetters\") ?? loose;\n\n  function isSimpleMemberExpression(expression) {\n    expression = skipTransparentExprWrappers(expression);\n    return (\n      t.isIdentifier(expression) ||\n      t.isSuper(expression) ||\n      (t.isMemberExpression(expression) &&\n        !expression.computed &&\n        isSimpleMemberExpression(expression.object))\n    );\n  }\n\n  /**\n   * Test if a given optional chain `path` needs to be memoized\n   * @param {NodePath} path\n   * @returns {boolean}\n   */\n  function needsMemoize(path) {\n    let optionalPath = path;\n    const { scope } = path;\n    while (\n      optionalPath.isOptionalMemberExpression() ||\n      optionalPath.isOptionalCallExpression()\n    ) {\n      const { node } = optionalPath;\n      const childKey = optionalPath.isOptionalMemberExpression()\n        ? \"object\"\n        : \"callee\";\n      const childPath = skipTransparentExprWrappers(optionalPath.get(childKey));\n      if (node.optional) {\n        return !scope.isStatic(childPath.node);\n      }\n\n      optionalPath = childPath;\n    }\n  }\n\n  return {\n    name: \"proposal-optional-chaining\",\n    inherits: syntaxOptionalChaining,\n\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        const { scope } = path;\n        // maybeWrapped points to the outermost transparent expression wrapper\n        // or the path itself\n        const maybeWrapped = findOutermostTransparentParent(path);\n        const { parentPath } = maybeWrapped;\n        const willReplacementCastToBoolean = willPathCastToBoolean(\n          maybeWrapped,\n        );\n        let isDeleteOperation = false;\n        const parentIsCall =\n          parentPath.isCallExpression({ callee: maybeWrapped.node }) &&\n          // note that the first condition must implies that `path.optional` is `true`,\n          // otherwise the parentPath should be an OptionalCallExpressioin\n          path.isOptionalMemberExpression();\n\n        const optionals = [];\n\n        let optionalPath = path;\n        // Replace `function (a, x = a.b?.c) {}` to `function (a, x = (() => a.b?.c)() ){}`\n        // so the temporary variable can be injected in correct scope\n        if (scope.path.isPattern() && needsMemoize(optionalPath)) {\n          path.replaceWith(template.ast`(() => ${path.node})()`);\n          // The injected optional chain will be queued and eventually transformed when visited\n          return;\n        }\n        while (\n          optionalPath.isOptionalMemberExpression() ||\n          optionalPath.isOptionalCallExpression()\n        ) {\n          const { node } = optionalPath;\n          if (node.optional) {\n            optionals.push(node);\n          }\n\n          if (optionalPath.isOptionalMemberExpression()) {\n            optionalPath.node.type = \"MemberExpression\";\n            optionalPath = skipTransparentExprWrappers(\n              optionalPath.get(\"object\"),\n            );\n          } else if (optionalPath.isOptionalCallExpression()) {\n            optionalPath.node.type = \"CallExpression\";\n            optionalPath = skipTransparentExprWrappers(\n              optionalPath.get(\"callee\"),\n            );\n          }\n        }\n\n        let replacementPath = path;\n        if (parentPath.isUnaryExpression({ operator: \"delete\" })) {\n          replacementPath = parentPath;\n          isDeleteOperation = true;\n        }\n        for (let i = optionals.length - 1; i >= 0; i--) {\n          const node = optionals[i];\n\n          const isCall = t.isCallExpression(node);\n          const replaceKey = isCall ? \"callee\" : \"object\";\n\n          const chainWithTypes = node[replaceKey];\n          let chain = chainWithTypes;\n\n          while (isTransparentExprWrapper(chain)) {\n            chain = chain.expression;\n          }\n\n          let ref;\n          let check;\n          if (isCall && t.isIdentifier(chain, { name: \"eval\" })) {\n            check = ref = chain;\n            // `eval?.()` is an indirect eval call transformed to `(0,eval)()`\n            node[replaceKey] = t.sequenceExpression([t.numericLiteral(0), ref]);\n          } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {\n            // If we assume getters are pure (avoiding a Function#call) and we are at the call,\n            // we can avoid a needless memoize. We only do this if the callee is a simple member\n            // expression, to avoid multiple calls to nested call expressions.\n            check = ref = chainWithTypes;\n          } else {\n            ref = scope.maybeGenerateMemoised(chain);\n            if (ref) {\n              check = t.assignmentExpression(\n                \"=\",\n                t.cloneNode(ref),\n                // Here `chainWithTypes` MUST NOT be cloned because it could be\n                // updated when generating the memoised context of a call\n                // expression\n                chainWithTypes,\n              );\n\n              node[replaceKey] = ref;\n            } else {\n              check = ref = chainWithTypes;\n            }\n          }\n\n          // Ensure call expressions have the proper `this`\n          // `foo.bar()` has context `foo`.\n          if (isCall && t.isMemberExpression(chain)) {\n            if (pureGetters && isSimpleMemberExpression(chain)) {\n              // To avoid a Function#call, we can instead re-grab the property from the context object.\n              // `a.?b.?()` translates roughly to `_a.b != null && _a.b()`\n              node.callee = chainWithTypes;\n            } else {\n              // Otherwise, we need to memoize the context object, and change the call into a Function#call.\n              // `a.?b.?()` translates roughly to `(_b = _a.b) != null && _b.call(_a)`\n              const { object } = chain;\n              let context = scope.maybeGenerateMemoised(object);\n              if (context) {\n                chain.object = t.assignmentExpression(\"=\", context, object);\n              } else if (t.isSuper(object)) {\n                context = t.thisExpression();\n              } else {\n                context = object;\n              }\n\n              node.arguments.unshift(t.cloneNode(context));\n              node.callee = t.memberExpression(\n                node.callee,\n                t.identifier(\"call\"),\n              );\n            }\n          }\n          let replacement = replacementPath.node;\n          // Ensure (a?.b)() has proper `this`\n          // The `parentIsCall` is constant within loop, we should check i === 0\n          // to ensure that it is only applied to the first optional chain element\n          // i.e. `?.b` in `(a?.b.c)()`\n          if (i === 0 && parentIsCall) {\n            // `(a?.b)()` to `(a == null ? undefined : a.b.bind(a))()`\n            const object = skipTransparentExprWrappers(\n              replacementPath.get(\"object\"),\n            ).node;\n            let baseRef;\n            if (!pureGetters || !isSimpleMemberExpression(object)) {\n              // memoize the context object when getters are not always pure\n              // or the object is not a simple member expression\n              // `(a?.b.c)()` to `(a == null ? undefined : (_a$b = a.b).c.bind(_a$b))()`\n              baseRef = scope.maybeGenerateMemoised(object);\n              if (baseRef) {\n                replacement.object = t.assignmentExpression(\n                  \"=\",\n                  baseRef,\n                  object,\n                );\n              }\n            }\n            replacement = t.callExpression(\n              t.memberExpression(replacement, t.identifier(\"bind\")),\n              [t.cloneNode(baseRef ?? object)],\n            );\n          }\n\n          if (willReplacementCastToBoolean) {\n            // `if (a?.b) {}` transformed to `if (a != null && a.b) {}`\n            // we don't need to return `void 0` because the returned value will\n            // eveutally cast to boolean.\n            const nonNullishCheck = noDocumentAll\n              ? ast`${t.cloneNode(check)} != null`\n              : ast`\n            ${t.cloneNode(check)} !== null && ${t.cloneNode(ref)} !== void 0`;\n            replacementPath.replaceWith(\n              t.logicalExpression(\"&&\", nonNullishCheck, replacement),\n            );\n            replacementPath = skipTransparentExprWrappers(\n              replacementPath.get(\"right\"),\n            );\n          } else {\n            const nullishCheck = noDocumentAll\n              ? ast`${t.cloneNode(check)} == null`\n              : ast`\n            ${t.cloneNode(check)} === null || ${t.cloneNode(ref)} === void 0`;\n\n            const returnValue = isDeleteOperation ? ast`true` : ast`void 0`;\n            replacementPath.replaceWith(\n              t.conditionalExpression(nullishCheck, returnValue, replacement),\n            );\n            replacementPath = skipTransparentExprWrappers(\n              replacementPath.get(\"alternate\"),\n            );\n          }\n        }\n      },\n    },\n  };\n});\n"],"names":["willPathCastToBoolean","path","maybeWrapped","findOutermostTransparentParent","node","parentPath","isLogicalExpression","operator","right","isSequenceExpression","expressions","length","isConditional","test","isUnaryExpression","isLoop","findParent","p","isTransparentExprWrapper","ast","template","expression","declare","api","options","assertVersion","loose","noDocumentAll","assumption","pureGetters","isSimpleMemberExpression","skipTransparentExprWrappers","t","isIdentifier","isSuper","isMemberExpression","computed","object","needsMemoize","optionalPath","scope","isOptionalMemberExpression","isOptionalCallExpression","childKey","childPath","get","optional","isStatic","name","inherits","syntaxOptionalChaining","visitor","willReplacementCastToBoolean","isDeleteOperation","parentIsCall","isCallExpression","callee","optionals","isPattern","replaceWith","push","type","replacementPath","i","isCall","replaceKey","chainWithTypes","chain","ref","check","sequenceExpression","numericLiteral","maybeGenerateMemoised","assignmentExpression","cloneNode","context","thisExpression","arguments","unshift","memberExpression","identifier","replacement","baseRef","callExpression","nonNullishCheck","logicalExpression","nullishCheck","returnValue","conditionalExpression"],"mappings":"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"}